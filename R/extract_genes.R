#' Extract genes
#'
#' Extract gene sequences based on GFF3 annotation file.
#'
#' @importFrom utils write.table
#' @param genes GFF annotation file as \code{\link[data.table:data.table]{data.table}}.
#' @param fasta Path to fasta file.
#' @param gff3 Path to GFF3 file or \code{data.table} generated by \code{\link{read_gff}}./
#' @param path_out Path to export fasta files for the specified genes.
#' @param filenames Whether to use \code{id} or \code{name} as filenames for the
#' exported files.
#' @param what What to export: either \code{gene}, \code{cds}, or \code{exons}.
#' @param translate Whether to translate the DNA sequence (if \code{what == "exons"}).

extract_genes <- function(genes, fasta, gff3 = NULL, path_out = NULL,
                          filenames = c("id", "name"),
                          what = c("gene", "cds", "exons"),
                          translate = FALSE){
  type <- NULL
  filenames <- match.arg(filenames, c("id", "name"))
  what <- match.arg(what, c("gene", "cds", "exons"))
  if (what != "gene" && is.null(gff3)){
    stop(sprintf("Please provide GFF3 file to extract %s.", what))
  }
  if (inherits(gff3, "character")){
    gff3 <- read_gff(gff3)
  }
  path_out <- fs::path_expand(path_out)
  exists <- fs::dir_exists(path_out)
  if (!fs::dir_exists(path_out)){
    fs::dir_create(path_out)
  }
  genes <- genes[type == what]
  sapply(seq_len(nrow(genes)), function(i){
    gene <- genes[i,]
    if (what == "gene"){
      temp_bed <- tempfile(fileext = ".bed")
      on.exit(unlink(temp_bed))
      write.table(genes, temp_bed, quote = FALSE, sep = "\t",
                  row.names = FALSE, col.names = FALSE)
      bedtoolsr::bt.getfasta(
        fi = fasta,
        bed = temp_bed,
        name = TRUE,
        s = TRUE,
        output = fs::path(path_out,
                          gsub("ID=", "",
                               stringr::str_split_fixed(gene$attributes, ";", 2)[,1]),
                          ext = "fasta")
      )
    } else{
     extract_exons(gene = gene, fasta = fasta, gff3 = gff3, path_out = path_out,
                   filenames = filenames, what = what, translate = translate)
    }
  })
}

#' Extract exons
#' @importFrom utils write.table
#' @noRd
extract_exons <- function(gene, fasta, gff3, path_out = NULL,
                          filenames = c("id", "name"),
                          what = c("cds", "exons"), translate = FALSE){
  start <- type <- NULL # due to NSE notes in R CMD check
  check_for_pkg("Biostrings")
  filenames <- match.arg(filenames, c("id", "name"))
  what <- match.arg(what, c("cds", "exons"))
  gene_id <- gsub("ID=", "", stringr::str_split_fixed(gene$attributes, ";", 2)[,1])
  core_id <- regmatches(gene_id, regexpr("v2\\.2_chr\\d+\\.\\d+", gene_id))

  # Extract parent attribute pattern to find related features
  # parent_pattern <- paste0("Parent=", gene_id, ";")
  child_pattern <- paste0("Parent=evm\\.model\\.", core_id, ";")

  # Filter GFF for features matching what we want
  features <- if(what == "cds") {
    gff3[type == "CDS" & grepl(child_pattern, attributes)]
  } else if (what == "exons"){
    gff3[type == "exon" & grepl(child_pattern, attributes)]
  }

  # If no features found, return
  if(nrow(features) == 0) {
    warning(sprintf("No %s found for gene `%s`.", what, gene_id))
    return(NULL)
  }

  # Sort features by position
  features <- features[order(start)]

  # Create temporary BED file for all features
  temp_bed <- tempfile(fileext = ".bed")
  on.exit(unlink(temp_bed))

  write.table(features, temp_bed, quote = FALSE, sep = "\t",
              row.names = FALSE, col.names = FALSE)

  exons <- bedtoolsr::bt.getfasta(
    fi = fasta,
    bed = temp_bed,
    name = TRUE,
    s = TRUE
  )

  seqs <- Biostrings::DNAStringSet(grep("^>", exons[[1]],
                                        invert = TRUE, value = TRUE))

  # Concatenate sequences
  concatenated <- Biostrings::DNAStringSet(do.call(c, as.list(seqs)))
  names(concatenated) <- paste(gene_id, what, sep = "_")

  # Output filename
  outfile <- if (filenames == "id") {
    gene_id
  } else {
    name_attr <- regmatches(gene$attributes, regexpr("Name=[^;]+", gene$attributes))
    gsub("Name=", "", name_attr)
  }
  base_name <- paste(outfile, what, sep = "_")
  if (translate){
    concatenated <- Biostrings::translate(concatenated)
    base_name <- paste(base_name, "AA", sep = "_")
  }
  file_path <- fs::path(path_out, base_name, ext = "fasta")
  # Write concatenated sequence
  Biostrings::writeXStringSet(
    concatenated,
    filepath = file_path)
}
